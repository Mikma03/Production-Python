## General-links

- Learn Makefiles
	- https://makefiletutorial.com/#top

- GNUÂ `make`
	- https://www.gnu.org/software/make/manual/make.html#Rule-Introduction

- keywords
	- https://www.gnu.org/software/make/manual/html_node/Quick-Reference.html


## YouTube videos

1. ["Makefiles Make Your Life Easier" by NeuralNine](https://www.youtube.com/watch?v=yWLkyN_Satk) - This video discusses why Makefiles are beneficial and how to use them effectively.
    
2. ["How to Create a Simple Makefile - Introduction to Makefiles" by Paul Programming](https://www.youtube.com/watch?v=_r7i5X0rXJk) - A tutorial on creating a simple makefile.
    
3. ["Makefiles: 95% of what you need to know" by Gabriel Parmer](https://www.youtube.com/watch?v=DtGrdB8wQ_8) - This tutorial covers different complexity levels of Makefiles.
    
4. ["makefile basics (beginner - intermediate) anthony explains #357" by anthonywritescode](https://www.youtube.com/watch?v=20GC9mYoFGs) - The video goes over the basics of makefiles, how to use them as a build system, and explains what `.PHONY` is.
    
5. ["Makefiles, but in English" by 801Labs](https://www.youtube.com/watch?v=FfG-QqRK4cY) - This video seems to provide an understandable explanation of Makefiles.


## Intro-general

Makefiles requires diving into a bit of history, purpose, and practical application. Let's break it down:

### 1. Historical Context & Purpose:

- **Origins:** Makefiles originated in the 1970s, designed as a part of the UNIX operating system. The main idea was to manage large software projects with lots of source code files.
- **Purpose:** They automate the process of compiling and linking large software projects, specifying how to derive the final build from the source files. Before Makefiles, developers had to manually execute the commands for each file, which was time-consuming and error-prone.

### 2. Understanding 'make' and 'Makefile':

- **'make':** This is a utility program that interprets Makefiles and is standard on UNIX-like systems such as Linux and macOS. When you run 'make' in the terminal, it looks for a file named 'Makefile' in the directory.
- **'Makefile':** This file contains a set of directives used by a 'make' utility to build an executable program from the source code. This process involves compiling source code, linking libraries, and producing an executable file.

### 3. Structure of a Makefile:

Makefiles are composed of "rules" with the following basic structure:

```markdown
targets : prerequisites
    recipe
```

- **Targets:** These are usually the names of files that are generated by a program, such as executables or object files.
- **Prerequisites:** These are files that need to be present before the current target can be processed. For instance, source files that need to be compiled.
- **Recipe:** The series of commands to execute in order to build the target from the prerequisites. These commands can be anything the terminal understands and are executed in a new shell.

### 4. Key Concepts:

- **Variables:** Makefiles allow you to define variables, which can be very useful for reusing values and keeping your Makefiles clean. For example, you might have a variable that holds the flags you want to use for compilation.
- **Pattern Rules:** These are rules that apply to multiple targets and can depend on corresponding prerequisites. They're useful for reducing repetition.
- **Automatic Variables:** These are variables set by 'make' that can be used in recipes. For example, `$@` for the name of the current target, and `$<` for the name of the current prerequisite.
- **Phony Targets:** These are targets that aren't actually the names of files; rather, they're just a way to run recipes regardless of the state of the file system. For example, 'clean' is often a phony target to remove built files and 'all' can be used to build everything.

### 5. Practical Example:

Imagine you have a project with two source files: `main.c` and `module.c`. You could have a Makefile like this:

```makefile
# Defining variables
CC=gcc
CFLAGS=-I.

# 'all' is a conventional target to build everything that should be built
all: program

# This rule tells make that 'program' depends on 'main.o' and 'module.o'
program: main.o module.o
    $(CC) -o program main.o module.o

# These rules tell make how to create the object files
main.o: main.c
    $(CC) -c -o main.o main.c $(CFLAGS)

module.o: module.c
    $(CC) -c -o module.o module.c $(CFLAGS)

# Phony target 'clean' for cleaning up the directory
.PHONY: clean
clean:
    rm -f *.o program

```

### 6. Running Makefile:

- You just navigate to the directory containing your Makefile and source code and type `make` into the terminal. The make utility will execute the Makefile's instructions and compile your program.
- If you modify a source file and type `make` again, only that file will be recompiled, not the entire project, saving time and resources.

### 7. Advanced Usage:

- **Including Other Makefiles:** For very large projects, Makefiles can be split into several files for readability and ease of use.
- **Conditional Parts of Makefiles:** 'make' supports conditional execution based on the value of variables. This feature can be used to adapt the build process to different UNIX-like systems.

### 8. Debugging Makefiles:

- Debugging Makefiles can sometimes be non-trivial, especially for large projects. However, 'make' provides several options for debugging, like the `-d` flag (print debugging information), `-n` or `--just-print` (display commands without executing them).

Understanding Makefiles deeply involves getting comfortable with these concepts and practicing by writing Makefiles for your projects. It's a powerful tool that, when mastered, can significantly streamline your build process.


## Makefile: Python

While Makefiles are traditionally associated with compiling code, particularly in languages like C or C++, they can be very useful in a Python development environment as well. In Python, you don't compile your code in the traditional sense, but you often have repetitive tasks that you need to run regularly. These can include:

- Running tests
- Creating virtual environments
- Installing dependencies
- Running linters or static analysis tools
- Building documentation
- Deploying your application

Here's how you can use Makefiles to automate these kinds of tasks in a Python project:

### 1. **Creating a Virtual Environment:**

You might want to create a virtual environment for your project to isolate your dependencies. Your Makefile can automate this.

```makefile
venv:
    python3 -m venv venv
    . venv/bin/activate
```

### 2. **Installing Dependencies:**

If you have a list of dependencies in a `requirements.txt` file, you can write a Makefile rule to install them.

```makefile
install:
    pip install -r requirements.txt
```

### 3. **Running Tests:**

You can automate the process of running your test suite with a Makefile. This example uses `pytest`, but you can replace it with your testing tool of choice.

```makefile
test:
    pytest
```

### 4. **Running Linters or Static Analysis:**

You can add a target in your Makefile to run linters (like `flake8`) or static analysis tools.

```makefile
lint:
    flake8 my_project
```
### 5. **Building Documentation:**

If you're using a system like Sphinx, you can automate the building of your documentation.

```makefile
docs:
    cd docs && make html
```

### 6. **Cleaning Up:**

You often end up with files that you want to clean up, like bytecode files or the build artifacts. A common practice is to have a `clean` target in your Makefile.

```makefile
clean:
    find . -type f -name '*.pyc' -delete
    find . -type d -name __pycache__ -delete
```

### 7. **Running the Application:**

For development, you can add a rule to run your application.

```makefile
run:
    python my_script.py
```

### Example of a Complete Makefile:

Here's what a simple Makefile for a Python project might look like with the rules we've discussed:

```makefile
.PHONY: venv install test lint docs clean run

venv:
    python3 -m venv venv
    . venv/bin/activate

install:
    pip install -r requirements.txt

test:
    pytest

lint:
    flake8 my_project

docs:
    cd docs && make html

clean:
    find . -type f -name '*.pyc' -delete
    find . -type d -name __pycache__ -delete

run:
    python my_script.py
```

To use this Makefile, you would just type `make` followed by the name of the target you want to build (e.g., `make test` or `make install`) in your terminal.

This approach allows you to standardize the commands and make your development process more efficient, especially when working in teams, as it avoids the "it works on my machine" problem. It also serves as good documentation for new team members, showing them the main commands they will use.